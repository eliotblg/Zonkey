import os
import re
import numpy as np
#from . chemsys import Chemsys
##import constant
# TODO use restart file with checkpoints

BOHR2ANG = 0.5291772109217
ANG2BOHR = 1.0 / BOHR2ANG

# Check if environment is set
def checkenvironment():
    if not 'GAUSS_EXEDIR' in os.environ:
        print('GAUSS_EXEDIR not set')
        return False
    if not 'GAUSS_SCRDIR' in os.environ:
        print('GAUSS_SCRDIR not set')
        return False
    return True

# Set environment; both variables are mandatory
def setupenvironment(executable=None, scratch=None):
    if executable != None:
        gaussiandir = os.path.dirname(executable)
        os.environ['GAUSS_EXEDIR'] = gaussiandir
    elif not 'GAUSS_EXEDIR' in os.environ:
        print('You have to provide a gaussian executable directory path')
        exit(1)
    if scratch != None:
        os.environ['GAUSS_SCRDIR'] = scratch 
    elif not 'GAUSS_SCRDIR' in os.environ:
        print('You have to provide a gaussian scratch directory path')
        exit(1)

# Print job file
def printjob(coords, jfile='jf', nproc=1, mem=1, ham='hf', basis='STO-3G', \
             meth='sp', charge=None, mult= None, extra=''):
    # if no charge or multiplicity is specified, load them from the chemsys
    if charge == None:
        charge = coords.charge
    if mult == None:
        mult = coords.mult
    method = meth
    hamiltonian = ham

    # open input file
    fp = open(jfile + '.com', 'w')
    # do some translation specific to gaussian
    if meth == 'sp':
        method = ''
    elif meth == 'grad':
        method = 'force'
    if ham == 'pbe0':
        hamiltonian = 'pbe1pbe'
    if basis != None and basis != '':
        hamiltonian = hamiltonian + '/' + basis
   
    # if QM/MM load extra keywords to include point charges
    if coords.nmmatoms > 0:
        extra = extra + ' Charge'
        if "nosymm" not in extra.lower():
            extra = extra + ' NoSymm'
        if meth == 'grad':
            extra = extra + ' Prop=(Read,Field) punch=derivatives' #'SCF=verytight'

    if os.path.isfile(jfile + '.chk') and not coords.firstcall:
        extra += ' Guess=Read'

    if coords.firstcall:
        coords.firstcall = False

    # write the actual job file
    # write the header
    fp.write('%nproc=' + str(nproc) + '\n')
    fp.write('%mem=' + str(int(round(mem))) + 'GB\n')
    fp.write('%Chk=' + jfile + '.chk\n')
    fp.write('#P ' + method + ' ' + hamiltonian + ' ' + extra + '\n\n')
    fp.write('Generated by Zonkey\n\n')
    fp.write(str(charge) + ' ' + str(mult) + '\n')

    if coords.nqmatoms == 0:
        print('No QM atoms defined in QM computation using Gaussian')
        exit(1)
    # QM/MM 
    else:
        for i in coords.qmatoms:
            c = coords.coords[i]
            fp.write(coords.atypes[i] + ' '+ str(c[0]*BOHR2ANG) + ' ' + \
                     str(c[1]*BOHR2ANG) + ' ' + str(c[2]*BOHR2ANG) + '\n')
        fp.write('\n')
        # write MM cordinates and charge values to be included into QM computation
        for i in coords.mmatoms:
            c = coords.coords[i]
            fp.write(str(c[0]*BOHR2ANG) + ' ' + str(c[1]*BOHR2ANG) + ' ' + \
                     str(c[2]*BOHR2ANG) + ' ' + str(coords.charges[i]) + '\n')
        fp.write('\n')
        for i in coords.mmatoms:
            c = coords.coords[i]
            fp.write(str(c[0]*BOHR2ANG) + ' ' + str(c[1]*BOHR2ANG) + ' ' + \
                     str(c[2]*BOHR2ANG) + '\n')
        

#TODO remove        # add grid point at MM atoms to evaluate the potential
        if meth == 'grad' and coords.nmmatoms > 0 and 0 == 1:
            fp.write('\n' + str(coords.nmmatoms) + ',2,41,42\n')
            # write the grid to .41 | output will be taken from .42
            fortf = open('fort.41', 'w')
            for i in coords.mmatoms:
                c = coords.coords[i]
                fortf.write('%20f%20f%20f\n'%(c[0]*BOHR2ANG, c[1]*BOHR2ANG, c[2]*BOHR2ANG))

            

            fortf.close()
                
    # mandatory blank line at the end 
    fp.write('\n')
    fp.close()

def runjob(executable, jfile='jf'):
    os.system(executable + ' < ' + jfile + '.com > ' + jfile + '.log')

#TODO def checkjob()

def extractdata(coords, jfile='jf', val='energy'):
    with open(jfile + '.log', 'r') as f:
        fdata = f.read()
    if val in ['energy', 'gradients']:
        # look after the energy
        energy = None
        reg = '.*SCF Done:.*'
        match = re.search(reg,fdata)
        if match:
            energy = float(match.group().split()[4])
            # if just energy needed, return here
            if val == 'energy':
                return energy 
        if energy == None:
            print('Could not locate energy in ' + jfile + '.log')
            exit(1)

        # read gradient
        grad = np.zeros([coords.natoms,3])
        # read QM gradients from fort.7 file generated by punch=derivatives keyw 
        if not os.path.isfile('fort.7'):
            print('No gradient output file found \n')
            exit(1) 
        with open('fort.7', 'r') as f:
            try:
                gdata = f.read().split('\n')
            except:
                print('Gaussian interface error: Cannot open fort.7 file\n')
        # store gradients at the right position switch D to E for scientific num 
        for i, qma in enumerate(coords.qmatoms):
            g = gdata[i].replace('D', 'E').split()
            grad[qma] = [ float(g[0]), float(g[1]), float(g[2]) ]

        if coords.nmmatoms:
            lines = fdata.split('\n')
            for il, line in enumerate(lines):
                if line[0:55] == '    Center     Electric         -------- Electric Field':
                    break
            il += 2 + coords.nqmatoms
            for it, mma in enumerate(coords.mmatoms):
                d = lines[il+it].split()
                q = coords.charges[mma] * -1.0
                grad[mma] = [float(d[2])*q, float(d[3])*q, float(d[4])*q]
#TODO remove        # get the MM gradients due to QM part
        if coords.nmmatoms and 0 == 1:
            fortf = open('fort.42','r')
            pot = 0.0
            for i in coords.mmatoms:
                t = fortf.readline().split()
                pot += float(t[3])
                d = fortf.readline().split()
                q = coords.charges[i] * -1.0
                grad[i] = [float(d[0])*q, float(d[1])*q, float(d[2])*q]
                ##print([coords.charges[jj] for jj in range(int(coords.natoms))])
            # energy += pot
            fortf.close()
    grad = np.array(grad) 
    print(grad)
    return energy, grad

def clean(filetodelete):
    extensions = ['.log', '.com', '.chk']
    for f in filetodelete:
        for e in extensions:
            if os.path.isfile(f + e):
                os.remove(f + e)
    for f in os.listdir():
        if f[0:4] == 'fort' and f.split('.')[-1].isdigit():
            os.remove(f)
            



